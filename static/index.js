var my_textarea = document.getElementById("sourceCodeTextarea");
var editor = CodeMirror.fromTextArea(my_textarea, {lineNumbers: true, mode:"python", smartIndent: true});

$("#compile").click(function() {
    $.ajax({
        url: "/bytecode",
        data: {sourceCode: editor.getValue()},
        dataType: "json",
        method: "POST",
        success: function(data){
          console.log(data)
	        addBytecode(data);
            // this comes from the tooltip.js script
	        registerTooltips();
	}
    });
});

function addBytecode(data) {
    // the data object is ultimately generated by the source_code_to_bytecode function in bitten.py
    if (typeof data !== "string") {
      var numFCM = Object.keys(data).length;
        if (numFCM > 0) {
            // clear the error box
            $("#syntaxError").text("");
            // remove the previous bytecode table, if it existed
            $("#bytecodeTable").detach();
            for(currFCM = 0; currFCM < numFCM; currFCM++){
              $("#tableColumn").append(makeTabs(data, currFCM));
              $("#tableColumn").append(makeTable(data, currFCM));
              console.log(Object.keys(data)[currFCM])
            }
        }
    } else {
        $("#syntaxError").text(data);
    }
}

function makeTable(data, numFCM) {
    return '<table class="table table-hover" id="bytecodeTable"><thead><tr><th>Source Code</th><th>Opname</th><th>Description</th></tr></thead><tbody>' + makeTableBody(data, numFCM) + '</tbody></table>';
}

function makeTabs(data, numFCM){
    return('<ul class="nav nav-tabs" id="product-table">'+ makeTabBody(data, numFCM)+ '</ul> ')
}

function makeTabBody(data, currFCM){
  console.log(data[0])
  var tabName = Object.keys(data)[currFCM].substring(1, Object.keys(data)[currFCM].length-1)
  return '<li><a href="'+ currFCM + '" data-toggle="tab">' + tabName + '</a></li>'
}

function makeTableBody(data, currFCM) {
    console.log(data[Object.keys(data)[currFCM]])
    var fcm = data[Object.keys(data)[currFCM]]
    return fcm.map(rowsFromCodePack).join("");
}

function rowsFromCodePack(code) {
    var firstRow = makeTableRow(code.source, code.bytecode[0]);
    var otherRows = code.bytecode.slice(1).map(function (b) { return makeTableRow('', b); });
    return firstRow + otherRows.join("");
}

function makeTableRow(source, bytecode) {
    if (bytecode) {
        var desc = getDescription(bytecode);
        return '<tr><td>' + source + '</td><td>' + bytecode.opname + '</td><td>' + desc + '</td></tr>';
    } else {
        return '<tr><td>' + source + '</td><td></td><td></td></tr>';
    }
}

function getDescription(bytecode) {
    switch (bytecode.opname) {
        case "LOAD_CONST":
            return "Push " + bytecode.argrepr + " onto the stack";
        case "STORE_NAME":
            return "Pop the top value off the stack and store it as " + bytecode.argrepr;
        case "LOAD_NAME":
            return "Retrieve the value stored as " + bytecode.argrepr + " and push it onto the stack";
        case "BINARY_ADD":
            return "Pop the top two values off the stack, add them, and push the result";
        default:
            return "";
    }
}
